---
title: 消除异步函数的传染性
date: 2025-04-29
updated: 2025-04-29
tags: [异步函数, 传染性, 函数式编程]
categories: [编程]
recommended: false
---

## 问题

我们都知道js是单线程的，如果想要异步代码同步执行的话，可以使用`async/await`来实现。
但是异步函数具有传染性，即一旦某个函数是异步的，所有调用它的函数也都必须是异步的。这种传染性使得代码变得难以理解和维护。

## 例题

```js
async function fetchData() {
  return await fetch('https://api.example.com/data');
}

async function processData() {
  const data = await fetchData();
  console.log(data);
}

processData();
```
`processData`函数依赖于`fetchData`函数，如果`fetchData`函数是异步的，那么`processData`函数也必须是异步的。
如何才能消除这种传染性呢？

## 解决方案

#### 1. 重组运行时间线
上述问题的根源在`fetch`是网络请求，所以导致`fetchData`和`processData`函数也必须是异步的。
所以需要重新组装整个运行时间线
![image](https://chopstickqy.github.io/images/2025-04-29/1.jpg)
在第一次调用`processData` -> `fetchData` -> `fetch` 时，直接抛出错误。
当`fetch`网络请求完毕后，将网络请求结果缓存起来，重新运行`processData`函数，同时将缓存的结果直接返回。

#### 2. `fetch`函数
当`fetch`函数被调用时，检查是否有缓存，如果有缓存，则直接返回缓存结果。如果没有缓存，则进行网络请求，并缓存结果。
![image](https://chopstickqy.github.io/images/2025-04-29/2.png)

#### 3. 代码实现
`fetch` 函数
```js
  function fetch(url) {
    if (cache[url]) {
      return cache[url];
    }
    const result = fetch(url);
    result.then(() => {
      cache[url] = result;
    });
    throw result;
  }

```
`fetchData` 函数
```js
async function fetchData() {
  return fetch('https://api.example.com/data');
}
```

`processData` 函数
```js
async function processData() {
  try {
    fetchData();
  } catch (error) {
    if (error instanceof Promise) {
      error.finally(() => processData())
    }
  }
}
```

#### 4. React 中的应用
在 React 中，Suspense 正是对「抛出 Promise 然后重试」这一思路的封装与标准化。

`React Query(TanStack Query)`
支持 Suspense 模式（通过 suspense: true 配置项）。
内部封装了缓存机制与错误处理，也通过“抛出 Promise”实现组件的同步式读取。
```js
const { data } = useQuery(['user'], fetchUser, { suspense: true });
```


React 官方文档中展示了如何使用 Suspense 和类似 wrapPromise 的机制来处理数据加载
[React Suspense 官方文档](https://17.reactjs.org/docs/concurrent-mode-suspense.html#what-suspense-is-not)












